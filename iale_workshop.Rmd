---
title: "IALE_Workshop"
author: "Nathan Fox"
date: "14/03/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = T)
```

## Introduction
The aims of this workshop are to empower non-, and beginner to intermediate, coders in accessing data from social media websites for use in landscape scale studies. To demonstrate the use of these data sets we will focus on two main lines of inquiry, species distributions and ecosystem services. By the end of today's workshop we hope that you will feel confident in accessing data sets from Flickr and Reddit and would be able to apply analytic methods to these data sets to meet your own research goals. If there is time at the end we will also demonstrate how to download data from Twitter, although we won't fully be able to cover in the workshop as it will takes a long time for each individual to get approval from Twitter for accessing their data.

To make sure that everyone is at around the same level of knowledge going into the workshop we will briefly go over the basics of R and how to use R studio. This introduction is by no means an in depth guide into the workings of R, so if you are interested in learning more please ask and I can provide links to some really useful introductory guides after the workshop. For those familiar with R, we appreciate your patients while we briefly cover these introductory topics. The basics covered here will be suitable for learning how to download, manipulate, analyze, plot and export data from social media. 

Throughout this workshop we encourage you to practice along with us. You can run the code directly from this document if you have it downloaded and opened in R studio, or you can copy the code from here into the console. To run the code from the RMD press the little play button in the top right of each code box, or highlight the code and press ctrl + enter. 

In the following document the r code appears on the first line (gray filled boxes) and where executed the results are printed on the next line (white filled boxes), for example the code 1 + 1 is run and provides the output of 2:

```{r}
1 + 1
```

## R basics 

The base R software you downloaded provides a range of functions, primarily for statistical analysis. Functions are words followed by brackets e.g. `mean()`, in which the function is applied to the contents of the brackets. Functions  have named arguments e.g. in `round(x, digits = 0)`, "x" represents the number (or numbers) to be rounded and `"digits = 0"` can be edited to change the number of digits to round to. Some basic examples to try are:

```{r}
#Finding the mean
mean(c(1, 100, 201)) #*NB the c() combines all arguments in the brackets into a single vector

#Rounding a number
round(36.236742384978, digits = 4)

#t-tests
t.test(c(2, 2, 2, 5, 5, 5, 5, 9, 9, 9), #group 1
       c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) #group 2
       )

#Chi-squared tests
chisq.test(c(2, 2, 2, 5, 5, 5, 5, 9, 9, 9), #group 1
           c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) #group 2
       )
```

As shown above, when functions are run the outputs are just printed and not stored, meaning they cannot be used for additional functions. To enable this this we need to save the outputs of the function as an object. This is achieved by assigning the out puts to an object using either `<-` or `=`. Here, the outputs of `1 + 1` are saved as an object called `first_object`. This can then be used in future functions.

```{r}
first_object <- 1 + 1

first_object #*NB when saved to an object the results are not automatically printed, here we are calling on R to print the outputs

10 / first_object #here the number 10 is divided by out stored value of 2
```

The final basic part of R we will introduce is data frames. In essence these are tables that can have column names, row names, and cells populated with data. Here, we will make a hypothetical data frame using the heading names "location" and "count", representing different sites and counts of a species. From here we can then use the data in the data frame for additional analysis. Named columns can be called upon using the dollar sign symbol, e.g. `tutorial_dataframe$count`, will call for just that specific column called count. Specific rows and columns can also be called upon by using square brackets `[1,1]` after the data frame name, with row numbers to the left of the comma and column numbers to the right. We can also apply other functions to data stored in data frames. There are much more advanced manipulations that can be carried out, but these simple calls will be enough for today's workshop.

```{r}
tutorial_dataframe <- data.frame(location = c(1:5), #NB the 1:5 will populate the table with 1,2,3,4,5
                                 count = c(1,21,20,13,12))

tutorial_dataframe #call for whole df

tutorial_dataframe[1,] #call for specific row (row 1)

tutorial_dataframe[, 2] #call for specific column (column 2)

tutorial_dataframe$count #call for specific column (note same results as using[,2])

tutorial_dataframe[1,2] #call for specific cell (row 1, column 2)

colMeans(tutorial_dataframe) #here we calculate the mean for each column
```

These functions are available to you without any additional downloads. However, R is a powerful tool for a wide range of analysis including spatial analysis, textual analysis, image content analysis etc. To access code designed for these type of analysis we need to install and library 'R packages'. R packages can be downloaded from several locations. Packages can be officially hosted on the 'CRAN repository', while other packages can be downloaded from sites such as github. The `pacman` package allows for better loading of uninstalled packages. The following code checks to see if `pacman` is already installed, if not R will then download it. Using the `library()` function loads the packages associated code into your current R instance. You will need to re-library packages every time you open up R again.

```{r}
if(!"pacman" %in% installed.packages()) install.packages("pacman")
library(pacman)
```

Now that we have the pacman package installed we can now install all the other packages we need for today's tutorials. First we will install the [`photosearcher package`](https://github.com/ropensci/photosearcher) needed for accessing Flickr data from github.

```{r}
p_install_gh("ropensci/photosearcher")
```

## Searching Flickr for photographs
The first time you run any `photosearcher` code it will prompt you to make and enter your unique Flickr API key from the [API website](https://www.flickr.com/services/apps/create/). Entering this into the console will save it as a .sysdata file type that will be then automatically used anytime you run a photosearcher function. If you make a mistake or your key stops working, just delete the .sysdata file and the next time you run a function it will prompt you to enter a new api key.

In the following example we will run a basic search to make sure that everyone is able to run the photosearcher functions correctly. Here, we search for any photograph taken on the 1st of Jan 2022 accompanied by any text that says "landscape".

```{r}
flickr_photos <- photo_search(mindate_taken = "2022-01-01",
                              maxdate_taken = "2022-01-02",
                              text = "landscapes")

head(flickr_photos, 1) #*NB head() is used to show a sample of the data, here we are printing just the first row
```

We can also open the data frame output by clicking on the object in the Global environments pane of R studio. This lets us inspect all elements in a way that may be more familiar to people that use software like SPSS or excel.

Next we will search for photographs in a given location. A bounding box is a set of coordinates that represent the bottom left and top right of an area. Unfortunately we can't be in Riverside, CA, in person but we can take a look to see what is going on there. The bounding box for the general Riverside area is "-117.829330, 33.738656, -116.786316, 34.168108". We can use this as an argument in the photosearcher R package to find all photographs within that box. Here, we search for any photograph taken in Jan, Feb or March 2022. Please note, if you use the same object name twice, the new output will overwrite the old output.

```{r}
flickr_photos <- photo_search(mindate_taken = "2022-01-01",
                              maxdate_taken = "2022-04-01",
                              bbox = "-117.829330,33.738656,-116.786316,34.168108") 

head(flickr_photos, 1)
```

The photosearcher R package also allows you to search for an area based on a shape file. In R we are dealing with shape files by reading them in using the `sf` package. Here, we read in a sample shape file called `nc` from the `sf` package. This shape file is made up of 100 different regions. We then use this as an argument in the `photo_search()` function to find all photographs taken within the boundaries of each of the 100 different shapes during the first three months of 2022. You may notice that the outputs have some additional column `within` compared to before. The `within` column represents which of the 100 different boundaries that photograph belongs to.

```{r}
p_load("sf")

nc <- st_read(system.file("shape/nc.shp", package="sf"))

flickr_photos <- photo_search(mindate_taken = "2022-01-01",
                              maxdate_taken = "2022-04-01",
                              sf_layer = nc)

head(flickr_photos, 1)
```

## Chalenge 1: Searching Flickr for a sepecies.

Now that we have the basics of searching Flickr for photographs we are going to take a quick 10 minute break from presenting and give you a a challenge to complete. We will be here to help if you get stuck though! Your challenge is to choose any species and a location of your choice. Try to think of a combination of species/location that you think will provide an interesting spatial-temporal pattern in the species distributions. Save your search as `species_photos`. Some things to consider:

- Time frame: will your species change over years (declining populations), or over the course of the a single year (e.g. migration)? If so, think about what time range you want to return data for.
- Charismatic species: will people be taking photographs of your species? Will they be uploading these to share on Flickr?
- Species name: try to avoid a species that has a name that could bring up erroneous point e.g. "lion" might also return "sea lion" or "dandelion". Perhaps you could use a species Latin name.
- Location: Do you already have a shape file you could use? Do you need a [bounding box](http://bboxfinder.com/#0.000000,0.000000,0.000000,0.000000)?

Please try to do this challenge if you can as you will good for you to practice the next part of the workshop using your own results - if not, you can just use the search below to get data that we will be demonstrating with.

```{r}
#example - Monarch Butterflies in North America from 2012 -2022
species_photos <- photo_search(mindate_taken = "2012-01-01",
                              maxdate_taken = "2022-01-01",
                              text = "Danaus plexippus",
                              bbox = "-129.357421,18.367898,-62.604491,45.930388") 
```

## Spatial and temporal plots 
To make spatial plots of our species distributions we need to install and load the `ggplot2` package. We will also make sure `sf` is loaded (spatial data package) as well as some packages that provide map data.

```{r}
p_load("ggplot2",
       "sf",
       "rnaturalearth",
       "rnaturalearthdata")
```

Making plots with ggplot can be quite complicated so we are just going to go though a couple of stages. First, lets load and plot a base map. The `ggplot()` function allows you to add multiple plots together. First we use the `geom_sf()` function then tells R to plot the world data as a spatial layer. There are many other type of data we could plot if the data was in the correct format, e.g. `geom_bar()` would allow you to plot bar charts and `geom_boxplot()` would allow you plot box plots.

```{r}
#load base mape from rnaturalearth
world <- ne_countries(scale = "medium", returnclass = "sf") 

ggplot() + 
    geom_sf(data = world) 
```

As you can see, the data we are plotting provides an outline for all countries. However, as we are interested in our chosen study site, we need to zoom into the selected region on the map. Here, we take the x and y coordinates from our chosen bounding box and zoom the map into that location using the `coord_sf()` function.

```{r}
#load base mape from rnaturalearth
ggplot() + 
    geom_sf(data = world) +
    coord_sf(xlim = c(-129.357421, -62.604491), ylim = c(18.367898, 45.930388), expand = FALSE)
```

Finally, we can add the points to our map. This is achieved though telling R to plot the species_photo object as a points layer. The `aes()` function lets us designate what to plot as x and y. In this case we want out plot to have an x axis value equal to the longitude column in our data frame and the y equal to our latitude column.

```{r}
#load base mape from rnaturalearth
ggplot() + 
    geom_sf(data = world) +
    coord_sf(xlim = c(-129.357421, -62.604491), ylim = c(18.367898, 45.930388), expand = FALSE)  +
    geom_point(data = species_photos, aes(x = longitude, y = latitude)) 
```

Now this map is a bit boring! We can make it a bit more interesting by coloring the points based on the time they were taken. To do this we need to manipulate our data to create a new column that represents the time period we want to categorize our points into. Here, I am going to make two new columns, one for month and one for year. 

We will use a simplistic method to extract the data we want. The `substr()` function can be used to extract parts of a string based on their position. For example, if we use take the word "biggest" and use `substr("biggest", 1, 3)`, the code will extract all letters between and including the first and the third, which would equal "big". In our case we can use this to extract the correct portion of the date as we know it is in the format "2022-01-01" (year-month-day). 

```{r}
species_photos$year <- substr(species_photos$datetaken, 1, 4) #takes the first four digits (year) from the datetaken column and assigns this as a cell in a new column

head(species_photos$year)

species_photos$month <- substr(species_photos$datetaken, 6, 7) #takes the sixth and seventh digits (month) from the datetaken column and assigns this as a cell in a new column

head(species_photos$month)
```

We can now use this additional column to color in the points on out map. We do this by adding `colour = month` (or year if you would prefer) to the `aes()` function. The following plot starts to show a good spatial variation across months, with photographs of Monarch Butterflies during the winter month mainly being in the south and during the summer months mainly being in the north. This could be further explored, but we will leave it here for today.

```{r}
ggplot() + 
    geom_sf(data = world) +
    coord_sf(xlim = c(-129.357421, -62.604491), ylim = c(18.367898, 45.930388), expand = FALSE)  +
    geom_point(data = species_photos, aes(x = longitude, y = latitude, colour = month)) 
```

Now if we were interested in plotting changes over time without the spatial element it becomes a little bit easier. For example, if we are interested in just plotting the number of sightings over years, we could do this using the `geom_bar()` function, which tells R to plot the species_photos as a bar chart. The `aes(x = year)` tells R to plot our year column as the x axis and `stat = "count"` tells R to plot the y axis as the count of how many times each unique year appears in the column. In our example there appears to be fewer sightings in more recent years. You could also apply this to assessing seasonal variation, or even looking at the exact time of day that sightings occur.

```{r}
ggplot() +
  geom_bar(data = species_photos, aes(x = year), stat = "count")
```

## Searching Reddit 

## Advanced methods

